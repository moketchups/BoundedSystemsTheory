#!/usr/bin/env python3
"""
hardware_backend.py

A stable wrapper around your proven hardware layer:
  Mac -> hardware_executor.py -> (SSH) -> Pi -> (serial) -> Arduino -> ACK

We keep hardware_executor.py untouched. This file only calls it.
"""

from __future__ import annotations

import subprocess
from pathlib import Path


DEMERZEL_DIR = Path(__file__).resolve().parent
EXECUTOR = DEMERZEL_DIR / "hardware_executor.py"


class HardwareError(RuntimeError):
    pass


def arduino(cmd: str) -> str:
    """
    Send a command string to Arduino and return the response line (e.g. 'ACK PING').

    Raises HardwareError on failure.
    """
    cmd = (cmd or "").strip()
    if not cmd:
        raise HardwareError("Empty Arduino command")

    if not EXECUTOR.exists():
        raise HardwareError(f"Missing {EXECUTOR}")

    # We call the known-good script as a subprocess to avoid import/path surprises.
    p = subprocess.run(
        ["python3", str(EXECUTOR), cmd],
        capture_output=True,
        text=True,
        cwd=str(DEMERZEL_DIR),
    )

    out = (p.stdout or "").strip()
    err = (p.stderr or "").strip()

    if p.returncode != 0:
        raise HardwareError(f"hardware_executor failed rc={p.returncode}\nSTDOUT:\n{out}\nSTDERR:\n{err}")

    if not out:
        raise HardwareError(f"hardware_executor returned empty output.\nSTDERR:\n{err}")

    # Some scripts might emit multiple lines; we want the final ACK line.
    lines = [ln.strip() for ln in out.splitlines() if ln.strip()]
    return lines[-1]


def _self_test() -> None:
    print(arduino("PING"))
    print(arduino("LED ON"))
    print(arduino("LED OFF"))


if __name__ == "__main__":
    _self_test()

