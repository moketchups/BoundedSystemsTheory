"""
DEMERZEL BRAIN CONTROLLER (SACRED-BASELINE CANDIDATE)

Core laws enforced here (non-negotiable):
1) Silence is default. No speech unless explicitly woken and then explicitly commanded.
2) A then B: Wake -> minimal ACK -> bounded command window.
3) Wake is wake. We NEVER route "wake remainder" from the wake utterance as a command.
4) Clarification is illegal unless we heard an actual command attempt inside the command window.
5) One control loop. One state machine. Deterministic transitions only.
6) Speech must never crash the system. Debug must never be spoken.

This file intentionally prioritizes boring predictability over cleverness.
"""

from __future__ import annotations

import json
import queue
import subprocess
import sys
import time
from dataclasses import dataclass, field
from typing import List, Optional, Tuple

# Optional deps used in many Demerzel builds
try:
    import sounddevice as sd  # type: ignore
except Exception:
    sd = None  # type: ignore

try:
    from vosk import Model, KaldiRecognizer  # type: ignore
except Exception as e:
    Model = None  # type: ignore
    KaldiRecognizer = None  # type: ignore
    _VOSK_IMPORT_ERR = e  # type: ignore

try:
    from fuzzywuzzy import fuzz  # type: ignore
except Exception:
    fuzz = None  # type: ignore


# ----------------------------
# Config
# ----------------------------

@dataclass
class BrainConfig:
    # Audio / Vosk
    sample_rate: int = 16000
    channels: int = 1
    device: Optional[int] = None  # None = default input device
    vosk_model_path: str = "vosk-model-small-en-us-0.15"

    # Wake/command behavior
    wake_aliases: List[str] = field(default_factory=lambda: ["demerzel"])
    wake_threshold: float = 0.62  # fuzzy match threshold (0..1)
    command_window: float = 7.5   # seconds, bounded window after wake
    post_wake_cooldown_seconds: float = 0.70  # ignore finals briefly after ACK (hard gate)
    suppress_clarify_after_wake_seconds: float = 1.25  # extra guard for clarify right after wake

    # Input hygiene
    min_final_chars_command: int = 3  # ignore ultra-short finals in command mode (unless yes/no)
    anti_echo_window: float = 1.1     # ignore exact match to last TTS for this long

    # TTS mic gate
    tts_mic_gate_seconds: float = 1.00

    # Logging
    verbose: bool = True


# ----------------------------
# Utility
# ----------------------------

def _clean_text(s: str) -> str:
    return " ".join((s or "").strip().lower().split())

def _now() -> float:
    return time.time()


# ----------------------------
# Router adapter
# ----------------------------

class RouterAdapter:
    """
    Adapter to whatever router_engine.py exposes in your repo.
    We try common patterns:
      - RouterEngine().process(text) -> List[str]
      - process(text) -> List[str]
    If not available, we fallback to a minimal router (time only).
    """

    def __init__(self) -> None:
        self._router = None
        self._process_fn = None

        try:
            import router_engine  # type: ignore
            # class RouterEngine
            if hasattr(router_engine, "RouterEngine"):
                self._router = router_engine.RouterEngine()  # type: ignore
                if hasattr(self._router, "process"):
                    self._process_fn = self._router.process  # type: ignore
            # module-level process
            if self._process_fn is None and hasattr(router_engine, "process"):
                self._process_fn = router_engine.process  # type: ignore
        except Exception:
            self._router = None
            self._process_fn = None

    def process(self, text: str) -> List[str]:
        t = (text or "").strip()
        if not t:
            return []

        if self._process_fn is not None:
            try:
                out = self._process_fn(t)
                if isinstance(out, list):
                    return [str(x) for x in out]
            except Exception:
                # Router failure must never crash voice loop
                return ["ERROR: router failure"]

        # Minimal fallback router (safe baseline)
        lt = _clean_text(t)
        if "time" in lt:
            return [f"OK: {time.strftime('%-I:%M %p')}" if sys.platform != "win32" else f"OK: {time.strftime('%I:%M %p')}"]
        if "sleep" in lt or "go to sleep" in lt:
            return ["OK: going idle"]
        return ["CLARIFY: I'm not sure what you want. Say one of: time, sleep."]


# ----------------------------
# Brain Controller
# ----------------------------

class BrainController:
    def __init__(self, cfg: Optional[BrainConfig] = None) -> None:
        self.cfg = cfg or BrainConfig()

        if Model is None or KaldiRecognizer is None:
            raise RuntimeError(f"Vosk not available: {_VOSK_IMPORT_ERR!r}")  # type: ignore

        if sd is None:
            raise RuntimeError("sounddevice not available (required for mic input).")

        # Vosk model/recognizer
        self.model = Model(self.cfg.vosk_model_path)
        self.rec = KaldiRecognizer(self.model, self.cfg.sample_rate)

        # Audio stream -> queue
        self.q: "queue.Queue[bytes]" = queue.Queue()
        self.stream = None

        # State machine
        self.state: str = "IDLE"  # IDLE | COMMAND | CONFIRM (reserved)
        self.state_deadline: float = 0.0

        # Gates
        self.mic_gate_until: float = 0.0          # prevents mic processing right after TTS
        self.command_gate_until: float = 0.0      # post-wake ignore window (A->B barrier)
        self.no_clarity_until: float = 0.0        # suppress clarification near wake

        # Anti-echo
        self.last_tts_text: str = ""
        self.last_tts_time: float = 0.0

        # Router
        self.engine = RouterAdapter()

    # ---- Audio plumbing ----

    def _audio_cb(self, indata, frames, time_info, status) -> None:
        try:
            if status:
                # never speak status; only debug print if verbose
                if self.cfg.verbose:
                    print(f"[AUDIO] status={status}", file=sys.stderr)
            self.q.put(bytes(indata))
        except Exception:
            # queue failures must not crash audio callback
            pass

    def _open_stream(self) -> None:
        if self.stream is not None:
            return

        self.stream = sd.RawInputStream(
            samplerate=self.cfg.sample_rate,
            blocksize=0,
            device=self.cfg.device,
            dtype="int16",
            channels=self.cfg.channels,
            callback=self._audio_cb,
        )
        self.stream.start()

    def _flush_audio_queue(self, max_chunks: int = 400) -> int:
        n = 0
        try:
            while n < max_chunks:
                self.q.get_nowait()
                n += 1
        except Exception:
            pass
        return n

    def _reset_recognizer(self) -> None:
        try:
            self.rec.Reset()
            if self.cfg.verbose:
                print("[GATE] Vosk recognizer reset.")
        except Exception:
            # must never crash loop
            pass

    # ---- Speech surface (single) ----

    def say(self, text: str) -> None:
        """
        The ONLY speech surface.
        - Never speaks debug/log lines
        - Never crashes the system
        """
        t = (text or "").strip()
        if not t:
            return

        # prevent debug leakage: never speak bracketed logs or JSON dumps
        lower = t.lower()
        if lower.startswith("[") or lower.startswith("{") or "kernel_json" in lower:
            # keep silent; debug may still print elsewhere
            return

        if self.cfg.verbose:
            print(f"[SAY] {t}")

        # record for anti-echo
        self.last_tts_text = _clean_text(t)
        self.last_tts_time = _now()

        # mic gate
        self.mic_gate_until = max(self.mic_gate_until, _now() + float(self.cfg.tts_mic_gate_seconds))

        # attempt macOS say; never crash if it fails
        try:
            if sys.platform == "darwin":
                subprocess.run(["say", t], check=False, stdout=subprocess.DEVNULL, stderr=subprocess.DEVNULL)
            else:
                # best-effort beep on non-mac
                sys.stdout.write("\a")
                sys.stdout.flush()
        except Exception:
            # silence is safer than crashing
            pass

        # flush + reset to reduce self-echo
        flushed = self._flush_audio_queue()
        if self.cfg.verbose:
            print(f"[GATE] Flushed {flushed} audio chunks.")
        self._reset_recognizer()

    def beep(self) -> None:
        # Minimal ack. Use terminal bell to avoid extra audio echo.
        try:
            sys.stdout.write("\a")
            sys.stdout.flush()
        except Exception:
            pass

    # ---- Wake logic ----

    def _wake_score(self, heard: str) -> Tuple[str, float]:
        """
        Returns (best_alias, score_0_to_1)
        Uses fuzzy match if available, else exact substring.
        """
        h = _clean_text(heard)
        best_alias = ""
        best_score = 0.0

        for a in self.cfg.wake_aliases:
            aa = _clean_text(a)
            if not aa:
                continue
            if fuzz is not None:
                s = float(fuzz.partial_ratio(h, aa)) / 100.0
            else:
                s = 1.0 if aa in h else 0.0
            if s > best_score:
                best_score = s
                best_alias = aa

        return best_alias, best_score

    def _strip_wake_alias(self, final_text: str, best_alias: str) -> str:
        """
        Deterministically remove alias from utterance ONCE, conservative.
        This is used ONLY for logging/ignoring remainder (never routed).
        """
        t = _clean_text(final_text)
        a = _clean_text(best_alias)
        if not a or not t:
            return final_text
        if a in t:
            # remove once
            out = t.replace(a, "", 1).strip()
            return out
        return t

    # ---- State transitions ----

    def _enter_command_state(self) -> None:
        self.state = "COMMAND"
        now = _now()
        self.state_deadline = now + float(self.cfg.command_window)

        # HARD A->B barrier: ignore all finals briefly after ACK
        self.command_gate_until = max(self.command_gate_until, now + float(self.cfg.post_wake_cooldown_seconds))

        # Clarify suppression window (additional guard)
        self.no_clarity_until = max(self.no_clarity_until, now + float(self.cfg.suppress_clarify_after_wake_seconds))

        if self.cfg.verbose:
            print(f"[STATE] COMMAND ({int(self.cfg.command_window)}s left)")
            print(f"[GATE] command_gate_until={self.command_gate_until:.2f} (now={now:.2f})")
            print(f"[GATE] no_clarity_until={self.no_clarity_until:.2f} (now={now:.2f})")

    def _back_to_idle(self) -> None:
        self.state = "IDLE"
        self.state_deadline = 0.0
        self.command_gate_until = 0.0
        self.no_clarity_until = 0.0
        if self.cfg.verbose:
            print("[STATE] IDLE")

    # ---- Speak selection ----

    def _choose_speak_line(self, lines: List[str]) -> Optional[str]:
        """
        Deterministic priority:
          1) CONFIRM:
          2) CLARIFY:
          3) ERROR:
          4) HARDWARE:
          5) OK:
        Otherwise speak nothing.
        """
        if not lines:
            return None

        # scan from bottom (latest wins)
        for line in reversed(lines):
            if line.strip().lower().startswith("confirm:"):
                return line.strip().split(":", 1)[1].strip()

        for line in reversed(lines):
            if line.strip().lower().startswith("clarify:"):
                return line.strip().split(":", 1)[1].strip()

        for line in reversed(lines):
            if line.strip().lower().startswith("error:"):
                return line.strip().split(":", 1)[1].strip()

        for line in reversed(lines):
            if line.strip().lower().startswith("hardware:"):
                return line.strip().split(":", 1)[1].strip()

        for line in reversed(lines):
            if line.strip().lower().startswith("ok:"):
                return line.strip().split(":", 1)[1].strip()

        return None

    # ---- Hygiene guards ----

    def _anti_echo_should_ignore(self, final_text: str) -> bool:
        ft = _clean_text(final_text)
        if not ft or not self.last_tts_text:
            return False
        if _now() - self.last_tts_time > float(self.cfg.anti_echo_window):
            return False
        if ft == self.last_tts_text:
            if self.cfg.verbose:
                print("[ANTI-ECHO] Ignored exact match to last TTS.")
            return True
        return False

    def _is_yes_no(self, s: str) -> bool:
        t = _clean_text(s)
        return t in {"yes", "no", "y", "n"}

    def _looks_like_real_command_attempt(self, final_text: str) -> bool:
        """
        Conservative: require at least min_final_chars_command and at least one alpha.
        (Still allows yes/no.)
        """
        t = (final_text or "").strip()
        if not t:
            return False
        if self._is_yes_no(t):
            return True
        if len(_clean_text(t)) < int(self.cfg.min_final_chars_command):
            return False
        return any(ch.isalpha() for ch in t)

    # ---- Main loop ----

    def run(self) -> None:
        self._open_stream()

        if self.cfg.verbose:
            print(f"[READY] Say '{self.cfg.wake_aliases[0]}' to wake. Ctrl+C to exit.")
            print(f"[WINDOW] command={self.cfg.command_window:.1f}s")
            print(f"[WAKE] threshold={self.cfg.wake_threshold:.2f}")
            print(f"[GATE] tts_mic_gate_seconds={self.cfg.tts_mic_gate_seconds:.2f}s")
            print(f"[GATE] post_wake_cooldown_seconds={self.cfg.post_wake_cooldown_seconds:.2f}s")
            print(f"[GATE] min_final_chars_command={self.cfg.min_final_chars_command}")

        try:
            while True:
                # Timeout state window
                if self.state != "IDLE" and _now() > self.state_deadline:
                    if self.cfg.verbose:
                        print("[STATE] window timeout -> IDLE")
                    self._back_to_idle()

                data = self.q.get()

                # Hard mic gate during/after TTS
                if _now() < self.mic_gate_until:
                    continue

                if self.rec.AcceptWaveform(data):
                    try:
                        result = json.loads(self.rec.Result() or "{}")
                    except Exception:
                        continue

                    text = (result.get("text") or "").strip()
                    if not text:
                        continue

                    final_text = text
                    if self.cfg.verbose:
                        print(f"[FINAL] {final_text}")

                    if self._anti_echo_should_ignore(final_text):
                        continue

                    best_alias, score = self._wake_score(final_text)
                    wake_detected = (score >= float(self.cfg.wake_threshold))

                    # -------------------------
                    # IDLE: only wake allowed
                    # -------------------------
                    if self.state == "IDLE":
                        if not wake_detected:
                            continue

                        if self.cfg.verbose:
                            print(f"[WAKE] detected alias='{best_alias}' score={score:.2f}")

                        # Minimal ACK (fast). Prefer beep to avoid self-echo.
                        self.beep()
                        self.say("Yes")  # keep as spoken confirmation (your system already expects this)

                        # Enter COMMAND state with strict gates
                        self._enter_command_state()

                        # LAW: Wake remainder is NEVER routed as a command.
                        remainder = self._strip_wake_alias(final_text, best_alias).strip()
                        if remainder and self.cfg.verbose:
                            print(f"[GATE] Ignoring wake-utterance remainder: {remainder!r}")

                        # Wait for next utterance
                        continue

                    # -------------------------
                    # COMMAND: accept one real command in bounded window
                    # -------------------------
                    if self.state == "COMMAND":
                        now = _now()

                        # A->B barrier: ignore any finals during post-wake cooldown
                        if now < self.command_gate_until:
                            if self.cfg.verbose:
                                print("[GATE] Ignored FINAL during post-wake cooldown.")
                            continue

                        # Only act on real command attempts
                        if not self._looks_like_real_command_attempt(final_text):
                            if self.cfg.verbose:
                                print("[GATE] Ignored non-command/noise in COMMAND.")
                            continue

                        # Route via router
                        lines = self.engine.process(final_text)
                        if self.cfg.verbose and lines:
                            for ln in lines:
                                print(ln)

                        speak = self._choose_speak_line(lines)

                        # If router yields nothing, be silent and keep waiting until timeout
                        if not speak:
                            continue

                        # Clarify is illegal during suppress window
                        is_clarify = ("not sure" in speak.lower()) or ("clarif" in speak.lower())
                        if is_clarify and now < self.no_clarity_until:
                            if self.cfg.verbose:
                                print("[GATE] Suppressed CLARIFY during no_clarity_until.")
                            continue

                        # Speak once, then return to IDLE (bounded authority)
                        self.say(speak)
                        self._back_to_idle()
                        continue

        except KeyboardInterrupt:
            if self.cfg.verbose:
                print("\n[EXIT] Ctrl-C")
        finally:
            try:
                if self.stream is not None:
                    self.stream.stop()
                    self.stream.close()
            except Exception:
                pass


# Backwards-compatible entrypoint patterns
def main() -> None:
    BrainController().run()

if __name__ == "__main__":
    main()

