from __future__ import annotations

"""
kernel_router.py

Deterministic router:
- Runs kernel classification (kernel_connect.run_kernel)
- Enforces confirmation policy
- Maps hardware intents -> hardware_executor
- Handles local-only safe intents (time, sleep ack)
- IMPORTANT: normalizes "l e d on" -> "led on" before routing
"""

import datetime
import subprocess
import re
from dataclasses import dataclass
from typing import Optional

from kernel_connect import (
    Intent,
    KernelResult,
    run_kernel,
    validate_kernel_result,
    kernel_result_to_json_str,
)

# Map kernel intent to hardware command string passed to hardware_executor.py
INTENT_TO_HW_CMD = {
    Intent.PING: "PING",
    Intent.LED_ON: "LED ON",
    Intent.LED_OFF: "LED OFF",
    # TIME_QUERY and SLEEP are handled locally (safe local intents)
}

YES_SET = {"yes", "y"}
NO_SET = {"no", "n"}


@dataclass
class RouterState:
    """
    Router state is explicit and minimal.

    If awaiting_confirmation is True, the only accepted next inputs are yes/no.
    """
    awaiting_confirmation: bool = False
    pending_intent: Optional[Intent] = None
    pending_hw_cmd: Optional[str] = None
    pending_prompt: Optional[str] = None


def _say(line: str) -> None:
    """
    Single speech surface (prints + best-effort speaks on macOS).
    Must not crash system.
    """
    # Always log
    try:
        print(line, flush=True)
    except Exception:
        pass

    # Best-effort TTS
    try:
        subprocess.run(["say", line], check=False)
    except Exception:
        try:
            print(f"[TTS_ERROR] {line}", flush=True)
        except Exception:
            pass


def _run_hardware_command(hw_cmd: str) -> str:
    """
    Executes hardware command through the existing stable hardware_executor.py.

    IMPORTANT: This keeps the hardware layer sealed as a black box.
    """
    # You may need to adjust the python path if hardware_executor.py moves.
    cmd = ["python3", "hardware_executor.py", hw_cmd]
    completed = subprocess.run(cmd, capture_output=True, text=True)

    # Always surface stderr explicitly (no silent failures)
    if completed.returncode != 0:
        raise RuntimeError(
            f"Hardware executor failed (exit={completed.returncode}).\n"
            f"STDOUT:\n{completed.stdout}\n"
            f"STDERR:\n{completed.stderr}\n"
        )

    return completed.stdout.strip()


def _handle_safe_local_intents(intent: Intent) -> Optional[str]:
    """
    Deterministic local handling for non-hardware actions.
    Returns a user-visible response string, or None if not handled.
    """
    if intent == Intent.TIME_QUERY:
        now = datetime.datetime.now()
        return now.strftime("Local time is %I:%M %p")
    if intent == Intent.SLEEP:
        # Policy ack only (no action)
        return "Sleep intent acknowledged. (No sleep action is implemented yet.)"
    return None


def _normalize_text(raw: str) -> str:
    """
    Fixes Vosk-style letter-by-letter outputs.
    Examples:
      "l e d on" -> "led on"
      "p i n g"  -> "ping"
      "l e d   o f f" -> "led off"

    Strategy:
      - lowercase
      - collapse whitespace
      - join runs of single-letter tokens into a word
    """
    s = (raw or "").strip().lower()
    if not s:
        return s

    # Collapse whitespace
    s = re.sub(r"\s+", " ", s)

    tokens = s.split(" ")
    out = []
    i = 0
    while i < len(tokens):
        # Detect run of single-letter tokens: a b c ...
        if len(tokens[i]) == 1 and tokens[i].isalpha():
            j = i
            letters = []
            while j < len(tokens) and len(tokens[j]) == 1 and tokens[j].isalpha():
                letters.append(tokens[j])
                j += 1

            # Only join if it's at least 2 letters (avoid turning "i" into weirdness)
            if len(letters) >= 2:
                out.append("".join(letters))
                i = j
                continue

        out.append(tokens[i])
        i += 1

    return " ".join(out)


def route_text(raw_text: str, state: RouterState, high_conf_threshold: float = 0.85) -> RouterState:
    """
    Main deterministic router entrypoint.

    - If awaiting confirmation: interpret raw_text as yes/no ONLY.
    - Else: normalize text, run kernel, validate result, enforce confirmation policy, execute if allowed.
    """
    t = _normalize_text(raw_text)

    # --- Confirmation step ---
    if state.awaiting_confirmation:
        ans = t.lower()

        if ans in YES_SET:
            if not state.pending_intent or not state.pending_hw_cmd:
                _say("ERROR: confirmation state corrupted; cleared.")
                return RouterState()

            _say(f"CONFIRMED: executing {state.pending_intent.value}")
            try:
                out = _run_hardware_command(state.pending_hw_cmd)
                _say(f"HARDWARE: {out}")
            except Exception as e:
                _say(f"ERROR: {e}")
            return RouterState()  # clear state

        if ans in NO_SET:
            _say("CANCELLED.")
            return RouterState()  # clear state

        # Not yes/no: keep waiting, be explicit
        _say("Awaiting confirmation. Reply 'yes' or 'no'.")
        return state

    # --- Normal routing step ---
    result: KernelResult = run_kernel(t)
    validate_kernel_result(result)

    # Optional: auditable boundary (only if env enables it in your kernel_connect)
    # We always provide a hook, but do not spam by default.
    # If you want, set DEMERZEL_DEBUG_KERNEL_JSON=1 in your runner.
    try:
        import os
        if os.getenv("DEMERZEL_DEBUG_KERNEL_JSON", "0") == "1":
            print("KERNEL_JSON:", kernel_result_to_json_str(result), flush=True)
    except Exception:
        pass

    # UNKNOWN intent: ask the kernel-provided clarification questions
    if result.intent == Intent.UNKNOWN:
        for q in (result.clarification_questions or []):
            _say(f"CLARIFY: {q}")
        return state

    # Handle local-only intents
    local_resp = _handle_safe_local_intents(result.intent)
    if local_resp is not None:
        # If kernel demanded confirmation, obey it even for local actions
        if result.requires_confirmation:
            _say(result.confirmation_prompt or "Confirm? (yes/no)")
            return RouterState(
                awaiting_confirmation=True,
                pending_intent=result.intent,
                pending_hw_cmd=None,
                pending_prompt=result.confirmation_prompt,
            )
        _say(local_resp)
        return state

    # Hardware-mapped intents only
    if result.intent not in INTENT_TO_HW_CMD:
        _say(f"REFUSE: intent {result.intent.value} has no execution mapping.")
        return state

    hw_cmd = INTENT_TO_HW_CMD[result.intent]

    # Confirmation gate
    if result.requires_confirmation:
        _say(result.confirmation_prompt or "Confirm? (yes/no)")
        return RouterState(
            awaiting_confirmation=True,
            pending_intent=result.intent,
            pending_hw_cmd=hw_cmd,
            pending_prompt=result.confirmation_prompt,
        )

    # Execute immediately
    _say(f"EXECUTING: {result.intent.value}")
    try:
        out = _run_hardware_command(hw_cmd)
        _say(f"HARDWARE: {out}")
    except Exception as e:
        _say(f"ERROR: {e}")

    return state


def repl() -> None:
    """
    Deterministic interactive test loop (text-based).
    This proves the router independent of voice.
    """
    _say("Demerzel Router REPL (type 'quit' to exit)")
    state = RouterState()

    while True:
        try:
            raw = input("> ")
        except (EOFError, KeyboardInterrupt):
            _say("\nExiting.")
            return

        if raw.strip().lower() in {"quit", "exit"}:
            _say("Bye.")
            return

        state = route_text(raw, state)


if __name__ == "__main__":
    repl()
