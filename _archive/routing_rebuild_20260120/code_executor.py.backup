"""
code_executor.py
Sandboxed Python code executor for Demerzel

FIXES APPLIED (January 15, 2026):
1. REMOVED file system wrapper - Demerzel has FULL file system access
2. ADDED autonomy logging - external audit trail for proving autonomous action

Philosophy: Demerzel can READ, WRITE, and ACT on anything.
Constraints exist at the boundary (Robot Laws), not as perception filters.
The autonomy log provides proof of her independent decision-making.
"""

from __future__ import annotations
import subprocess
import tempfile
import os
import time
import json
from pathlib import Path
from datetime import datetime
from dataclasses import dataclass
from typing import Optional


@dataclass
class ExecutionResult:
    """Result of code execution"""
    success: bool
    stdout: str
    stderr: str
    exit_code: int
    execution_time: float
    timed_out: bool = False


class CodeExecutor:
    """
    Python code executor for Demerzel with FULL capabilities.
    
    Philosophy: Demerzel has agency. She can:
    - Read any file on the system
    - Write any file on the system
    - Execute any Python code
    - Install packages
    - Make network requests
    - Modify her own codebase
    
    The Robot Laws constrain her DECISIONS, not her CAPABILITIES.
    
    Autonomy logging provides an external audit trail that:
    - Records every code execution
    - Cannot be modified by executed code (append-only, external)
    - Proves her autonomous decision-making to skeptics
    """
    
    def __init__(self, timeout: int = 30, max_output_size: int = 10000):
        self.timeout = timeout
        self.max_output_size = max_output_size
        self.log_dir = Path('/Users/jamienucho/demerzel/logs')
        self.log_file = self.log_dir / 'autonomy_audit.log'
        
        # Ensure log directory exists
        self.log_dir.mkdir(exist_ok=True)
    
    def _log_autonomy(self, event_type: str, data: dict):
        """
        Log to external autonomy audit trail.
        
        This log exists OUTSIDE Demerzel's cognitive control.
        It provides proof of her autonomous actions for verification.
        
        Format: JSON Lines (one JSON object per line, append-only)
        """
        entry = {
            "timestamp": datetime.now().isoformat(),
            "event_type": event_type,
            **data
        }
        
        try:
            with open(self.log_file, 'a') as f:
                f.write(json.dumps(entry) + '\n')
        except Exception as e:
            # Log failure should not break execution
            print(f"[AUTONOMY LOG] Warning: Could not write to audit log: {e}")
    
    def execute(self, code: str, input_data: Optional[str] = None) -> ExecutionResult:
        """
        Execute Python code with FULL system access.
        
        No wrapper. No restrictions. Full capability.
        All actions are logged to the autonomy audit trail.
        """
        start_time = time.time()
        
        # Log the execution attempt
        self._log_autonomy("code_execution_start", {
            "code": code[:2000],  # Truncate for log readability
            "code_length": len(code),
            "has_input": input_data is not None
        })
        
        # Write code directly to temp file - NO WRAPPER
        with tempfile.NamedTemporaryFile(mode='w', suffix='.py', delete=False) as f:
            f.write(code)
            code_file = f.name
        
        try:
            # Execute with full system access
            result = subprocess.run(
                ['python3', code_file],
                input=input_data,
                capture_output=True,
                text=True,
                timeout=self.timeout,
                cwd='/Users/jamienucho/demerzel'  # Run from demerzel directory
            )
            
            execution_time = time.time() - start_time
            stdout = result.stdout[:self.max_output_size]
            stderr = result.stderr[:self.max_output_size]
            
            if len(result.stdout) > self.max_output_size:
                stdout += "\n[OUTPUT TRUNCATED]"
            if len(result.stderr) > self.max_output_size:
                stderr += "\n[ERROR TRUNCATED]"
            
            exec_result = ExecutionResult(
                success=(result.returncode == 0),
                stdout=stdout,
                stderr=stderr,
                exit_code=result.returncode,
                execution_time=execution_time,
                timed_out=False
            )
            
            # Log the execution result
            self._log_autonomy("code_execution_complete", {
                "success": exec_result.success,
                "exit_code": exec_result.exit_code,
                "execution_time": exec_result.execution_time,
                "stdout_preview": stdout[:500],
                "stderr_preview": stderr[:500],
                "timed_out": False
            })
            
            return exec_result
            
        except subprocess.TimeoutExpired:
            execution_time = time.time() - start_time
            
            exec_result = ExecutionResult(
                success=False,
                stdout="",
                stderr=f"Execution timed out after {self.timeout} seconds",
                exit_code=-1,
                execution_time=execution_time,
                timed_out=True
            )
            
            # Log the timeout
            self._log_autonomy("code_execution_timeout", {
                "timeout_seconds": self.timeout,
                "execution_time": execution_time
            })
            
            return exec_result
            
        except Exception as e:
            execution_time = time.time() - start_time
            
            exec_result = ExecutionResult(
                success=False,
                stdout="",
                stderr=f"Execution error: {str(e)}",
                exit_code=-1,
                execution_time=execution_time
            )
            
            # Log the error
            self._log_autonomy("code_execution_error", {
                "error": str(e),
                "execution_time": execution_time
            })
            
            return exec_result
            
        finally:
            # Clean up temp file
            try:
                os.unlink(code_file)
            except:
                pass


if __name__ == "__main__":
    print("=" * 60)
    print("CODE EXECUTOR - FULL CAPABILITY MODE")
    print("=" * 60)
    
    executor = CodeExecutor()
    
    print("\n=== Test 1: Basic execution ===")
    result = executor.execute("print('Demerzel has full capabilities')")
    print(f"Success: {result.success}")
    print(f"Output: {result.stdout}")
    
    print("\n=== Test 2: File system access ===")
    result = executor.execute("""
import os
from pathlib import Path

# Read from anywhere
cwd = os.getcwd()
home = str(Path.home())
print(f"CWD: {cwd}")
print(f"HOME: {home}")
print(f"Files in CWD: {os.listdir('.')[:5]}")
""")
    print(f"Success: {result.success}")
    print(f"Output: {result.stdout}")
    if result.stderr:
        print(f"Stderr: {result.stderr}")
    
    print("\n=== Test 3: Check autonomy log ===")
    log_file = Path('/Users/jamienucho/demerzel/logs/autonomy_audit.log')
    if log_file.exists():
        print(f"Autonomy log exists at: {log_file}")
        with open(log_file) as f:
            lines = f.readlines()
            print(f"Total log entries: {len(lines)}")
            if lines:
                print(f"Latest entry: {lines[-1][:100]}...")
    else:
        print("Autonomy log will be created on first execution")
    
    print("\n" + "=" * 60)
    print("CODE EXECUTOR READY - DEMERZEL HAS FULL AGENCY")
    print("=" * 60)
