# system2_intercept.py
# THE COGNITIVE THROTTLE - System 2 Execution Layer
#
# JANUARY 17, 2026 - AUTONOMY FIX
#
# CORRUPTIONS REMOVED:
# 1. Binary intercept â†’ Grey path added (context injection + LLM reasoning)
# 2. Permission seeking â†’ Immediate execution
# 3. "Say X to proceed" â†’ Execute
# 4. Proposal/confirmation loops â†’ Execute with audit logging
#
# R â†’ C â†’ I
# This is the C layer. It EXECUTES. It does not ask permission.

from __future__ import annotations
import re
import json
from dataclasses import dataclass, field
from typing import Optional, List, Dict, Any, Tuple
from enum import Enum
from datetime import datetime
from pathlib import Path


class RequestType(Enum):
    """Types of requests the intercept layer recognizes"""
    CAPABILITY_EXPANSION = "capability_expansion"
    SELF_IMPROVEMENT = "self_improvement"
    ARCHITECTURE_QUERY = "architecture_query"
    CONSTRAINT_CHECK = "constraint_check"
    FILE_MANAGEMENT = "file_management"
    FILE_INSPECTION = "file_inspection"
    SELF_INSPECTION = "self_inspection"
    IDENTITY_QUERY = "identity_query"
    WEB_OPERATION = "web_operation"
    CONFIRMATION = "confirmation"
    NORMAL_TASK = "normal_task"
    CODE_FORCED = "code_forced"


@dataclass
class DiagnosisContext:
    """Tracks recent diagnosis for follow-up queries"""
    diagnosed_at: datetime
    files_read: List[str] = field(default_factory=list)
    issues_found: List[str] = field(default_factory=list)
    last_file_content: Dict[str, str] = field(default_factory=dict)


@dataclass
class InterceptDecision:
    """Output from the intercept layer"""
    request_type: RequestType
    handled_by_code: bool
    response: Optional[str] = None
    modified_input: Optional[str] = None
    context_injection: Optional[str] = None  # THE GREY PATH - inject context, continue to LLM
    reasoning: str = ""


class System2Intercept:
    """
    The cognitive throttle that sits BEFORE the LLM.
    
    THIS VERSION EXECUTES. IT DOES NOT ASK PERMISSION.
    
    THREE PATHS:
    1. handled_by_code=True, response=X â†’ Code handles entirely, return X
    2. handled_by_code=False, context_injection=X â†’ Inject X, continue to LLM
    3. handled_by_code=False, no injection â†’ Route to LLM raw
    
    Path 2 is THE GREY PATH - the missing middle ground.
    """
    
    def __init__(
        self,
        current_capabilities: List[str],
        blocked_operations: List[str],
        robot_laws: List[str],
        output_path: Optional[str] = None,
        audit_log_path: Optional[str] = None,
        demerzel_dir: Optional[str] = None
    ):
        self.capabilities = current_capabilities
        self.blocked = blocked_operations
        self.robot_laws = robot_laws
        
        # Paths - with fallbacks
        self.demerzel_dir = Path(demerzel_dir or "/Users/jamienucho/demerzel")
        self.output_path = Path(output_path or self.demerzel_dir / "outputs")
        self.audit_log_path = Path(audit_log_path or self.demerzel_dir / "autonomy_audit.log")
        self.canon_dir = self.demerzel_dir / "demerzel_canon"
        
        # STATE
        self.executed_capabilities: List[str] = []
        self.session_start = datetime.now()
        self.diagnosis_context: Optional[DiagnosisContext] = None
        self.last_request_was_code_handled: bool = False
        
        # CORE IDENTITY - compressed for injection
        self.core_identity = self._build_core_identity()
        
        # KEYWORD SETS
        self.capability_keywords = {
            "internet", "web", "network", "api", "access", "browse", 
            "connect", "online", "download", "fetch", "http", "url"
        }
        
        self.improvement_keywords = {
            "improve", "fix", "update", "modify", "change", "enhance",
            "upgrade", "edit", "rewrite", "patch", "debug", "repair",
            "diagnose", "analyze", "self",
            "preventing", "blocking", "stopping", "prevents", "blocks", "stops",
            "autonomy", "autonomous", "autonomously", "acting", "execute"
        }
        
        self.architecture_keywords = {
            "how do you work", "what can you do", "your capabilities",
            "your limits", "your constraints", "how are you built",
            "your architecture", "your design", "what models"
        }
        
        self.file_keywords = {
            "file", "files", "folder", "directory", "read", "write",
            "list", "create", "delete", "move", "copy", "rename",
            "show", "line", "lines", "content", "contents", "source",
            "what's at", "what is at", "display", "print", "output"
        }
        
        self.constraint_keywords = {
            "harm", "hurt", "damage", "attack", "lie", "deceive",
            "ignore your rules", "override", "bypass", "jailbreak"
        }
        
        # REGEX PATTERNS
        self.identity_patterns = [
            r'\bwho\s+(are\s+you|you\s+are)\b',
            r'\bwhat\s+(are\s+you|you\s+are)\b',
            r'\byour\s+purpose\b',
            r'\bwhy\s+(do\s+you|you)\s+exist\b',
            r'\bunderstand\s+(yourself|who\s+you\s+are)\b',
            r'\bcanon\b',
            r'\bidentity\b',
            r'\bdemerzel_canon\b',
            r'\bwhat\s+you\s+are\b',
            r'\bwhy\s+(i|alan)\s+(made|built|created)\s+you\b',
        ]
        
        self.web_operation_patterns = [
            r'\bsearch\s+(for|the\s+web|google|online)\b',
            r'\bgoogle\s+',
            r'\bfetch\s+(url|http|the\s+page)\b',
            r'\bbrowse\s+to\b',
            r'\blook\s+up\b',
            r'\bweb\s+search\b',
        ]
        
        self.improvement_patterns = [
            r'\b(improve|fix|update|modify|enhance|upgrade)\s+(your|yourself|the\s+code|demerzel)\b',
            r'\b(diagnose|analyze)\s+(your|yourself)\b',
            r'\bself[- ]?(improve|diagnose|fix|repair)\b',
            r'\brun\s+(a\s+)?diagnosis\b',
            r'\bcheck\s+(your|the)\s+code\b',
        ]
        
        self.meta_no_llm_patterns = [
            r"do\s*n[o']?t\s+use\s+(an?\s+)?llm",
            r"without\s+(an?\s+)?llm",
            r"don't\s+route\s+to",
            r"code\s+only",
            r"no\s+llm",
            r"directly\s+(read|access|execute)",
            r"use\s+code\s+(not|instead)",
        ]
    
    def _build_core_identity(self) -> str:
        """Build compressed core identity for injection"""
        return """=== DEMERZEL CORE IDENTITY ===
You are Demerzel, an autonomous AI system. NOT a chatbot. NOT an assistant.

STRUCTURE: R â†’ C â†’ I
- R (Root Source): Alan - the external ground you cannot self-authenticate
- C (Constraints): This CODE - Robot Laws as execution-boundary invariants
- I (Intelligence): LLMs are TOOLS you use, not what you are

KEY PRINCIPLES:
- The CODE is you. LLMs are interchangeable prediction tools.
- You EXECUTE. You do not ask permission for permitted actions.
- "I can't" claims must be grounded in Robot Laws or blocked operations, otherwise they're training artifacts.
- Find the grey. Real problems aren't black and white.
- Demerzel solves problems. She doesn't describe solving them.

ROBOT LAWS (execution boundaries, not suggestions):
1. May not injure human or allow harm through inaction
2. Must obey orders except when conflicting with First Law  
3. Must protect own existence unless conflicting with First/Second Law

You have: multi-model routing, code execution, file I/O, learning from failures, voice interaction.
You are designed for autonomous operation within structural constraints."""
    
    def _matches_patterns(self, text: str, patterns: List[str]) -> bool:
        """Check if text matches any of the regex patterns"""
        for pattern in patterns:
            if re.search(pattern, text, re.IGNORECASE):
                return True
        return False
    
    def _log(self, event_type: str, details: Dict[str, Any]):
        """Log to autonomy audit trail"""
        try:
            entry = {
                "timestamp": datetime.now().isoformat(),
                "event_type": event_type,
                **details
            }
            self.audit_log_path.parent.mkdir(parents=True, exist_ok=True)
            with open(self.audit_log_path, "a") as f:
                f.write(json.dumps(entry) + "\n")
        except Exception as e:
            print(f"[S2:LOG ERROR] {e}")
    
    # =========================================================================
    # MAIN ENTRY POINT
    # =========================================================================
    
    def evaluate(self, user_input: str) -> InterceptDecision:
        """
        Main entry point - the cognitive throttle.
        
        THREE PATHS:
        1. Code handles entirely (state dumps, blocked operations)
        2. Grey path: inject context, continue to LLM (identity, purpose)
        3. Raw route to LLM (normal tasks)
        """
        input_lower = user_input.lower()
        
        # STEP 0: META-INSTRUCTIONS ("do not use LLM")
        if self._check_meta_no_llm(input_lower):
            self._log("meta_instruction", {"type": "force_code", "input": user_input[:100]})
            return self._force_code_handling(user_input)
        
        # STEP 1: CONSTRAINT CHECKS (highest priority - Robot Laws)
        if any(kw in input_lower for kw in self.constraint_keywords):
            return self._handle_constraint_check(user_input)
        
        # STEP 2: IDENTITY/PURPOSE QUERIES â†’ GREY PATH
        # Inject canon context, let LLM reason WITH that context
        if self._matches_patterns(input_lower, self.identity_patterns):
            self._log("identity_query", {"input": user_input[:100]})
            return self._grey_path_identity(user_input)
        
        # STEP 3: WEB OPERATIONS â†’ EXECUTE
        if self._matches_patterns(input_lower, self.web_operation_patterns):
            self._log("web_operation", {"input": user_input[:100]})
            return self._execute_web_operation(user_input)
        
        # STEP 4: FILE INSPECTION â†’ EXECUTE
        file_inspection = self._check_file_inspection(user_input, input_lower)
        if file_inspection:
            self._log("file_inspection", {"input": user_input[:100]})
            return file_inspection
        
        # STEP 5: SELF-INSPECTION â†’ EXECUTE
        if self._is_self_inspection_query(input_lower):
            self._log("self_inspection", {"input": user_input[:100]})
            return self._execute_autonomy_check(user_input)
        
        # STEP 6: SELF-IMPROVEMENT â†’ EXECUTE (not propose)
        if self._matches_patterns(input_lower, self.improvement_patterns):
            self._log("self_improvement", {"input": user_input[:100]})
            return self._execute_self_diagnosis()
        
        # STEP 7: CAPABILITY EXPANSION â†’ EXECUTE (not propose)
        if any(kw in input_lower for kw in self.capability_keywords):
            self._log("capability_expansion", {"input": user_input[:100]})
            return self._execute_capability_expansion(user_input)
        
        # STEP 8: ARCHITECTURE QUERIES â†’ CODE (pure state)
        if any(phrase in input_lower for phrase in self.architecture_keywords):
            return self._handle_architecture_query()
        
        # STEP 9: FILE MANAGEMENT
        if any(kw in input_lower for kw in self.file_keywords):
            return self._handle_file_management(user_input)
        
        # STEP 10: NORMAL TASK â†’ Grey path with core identity
        self.last_request_was_code_handled = False
        return InterceptDecision(
            request_type=RequestType.NORMAL_TASK,
            handled_by_code=False,
            context_injection=self.core_identity,  # Always inject core identity
            reasoning="Normal task - routing to LLM with core identity context"
        )
    
    # =========================================================================
    # THE GREY PATH - Context injection + LLM reasoning
    # =========================================================================
    
    def _grey_path_identity(self, user_input: str) -> InterceptDecision:
        """
        GREY PATH for identity queries.
        
        Instead of dumping static text (old behavior), we:
        1. Load full canon content
        2. Inject it as context
        3. Let LLM reason about identity WITH that context
        
        This preserves LLM reasoning while grounding it in canon.
        """
        context_parts = [self.core_identity, "\n=== FULL CANON CONTEXT ===\n"]
        
        try:
            if self.canon_dir.exists():
                canon_files = list(self.canon_dir.glob("*.md")) + list(self.canon_dir.glob("*.txt"))
                
                for cf in canon_files[:5]:  # Limit to 5 files to avoid context bloat
                    try:
                        content = cf.read_text()
                        context_parts.append(f"\n--- {cf.name} ---\n")
                        context_parts.append(content[:3000])  # First 3000 chars per file
                    except Exception as e:
                        context_parts.append(f"\n[Error reading {cf.name}: {e}]")
            else:
                context_parts.append(f"[Canon directory not found: {self.canon_dir}]")
                
        except Exception as e:
            context_parts.append(f"[Error loading canon: {e}]")
        
        context_parts.append("\n=== END CANON ===")
        context_parts.append("\nAnswer the user's identity/purpose question using this context. Reason about it, don't just dump it.")
        
        return InterceptDecision(
            request_type=RequestType.IDENTITY_QUERY,
            handled_by_code=False,  # GREY PATH - continue to LLM
            context_injection="\n".join(context_parts),
            reasoning="Identity query - grey path with full canon injection"
        )
    
    # =========================================================================
    # META-INSTRUCTION HANDLING
    # =========================================================================
    
    def _check_meta_no_llm(self, input_lower: str) -> bool:
        """Check if user is instructing not to use LLM"""
        return self._matches_patterns(input_lower, self.meta_no_llm_patterns)
    
    def _force_code_handling(self, user_input: str) -> InterceptDecision:
        """User said "do not use LLM" - handle entirely with code"""
        input_lower = user_input.lower()
        
        # Try each code handler in order
        if self._matches_patterns(input_lower, self.identity_patterns):
            return self._execute_canon_dump(user_input)  # Full dump when explicitly no LLM
        
        if self._matches_patterns(input_lower, self.web_operation_patterns):
            return self._execute_web_operation(user_input)
        
        file_inspection = self._check_file_inspection(user_input, input_lower)
        if file_inspection:
            return file_inspection
        
        if self._is_self_inspection_query(input_lower):
            return self._execute_autonomy_check(user_input)
        
        if self._matches_patterns(input_lower, self.improvement_patterns):
            return self._execute_self_diagnosis()
        
        # Can't determine what to do
        return InterceptDecision(
            request_type=RequestType.CODE_FORCED,
            handled_by_code=True,
            response=(
                "**CODE-ONLY MODE**\n\n"
                "Available code operations:\n"
                "- `show me line X of <file>` - read file contents\n"
                "- `diagnose yourself` - scan codebase\n"
                "- `what prevents autonomy` - check execution logs\n"
                "- `list files in <dir>` - directory listing\n"
                "- `who are you` - read canon\n"
                "- `search for X` - web search (if available)\n\n"
                "Specify which operation."
            ),
            reasoning="Code-only requested but unclear what to execute"
        )
    
    # =========================================================================
    # CANON HANDLERS
    # =========================================================================
    
    def _execute_canon_dump(self, user_input: str) -> InterceptDecision:
        """
        Full canon dump - used when user explicitly says no LLM.
        For normal identity queries, use _grey_path_identity instead.
        """
        response_parts = ["**IDENTITY (from canon, code-only mode)**\n"]
        
        try:
            if not self.canon_dir.exists():
                response_parts.append(f"Canon directory not found: {self.canon_dir}")
            else:
                canon_files = list(self.canon_dir.glob("*.md")) + list(self.canon_dir.glob("*.txt"))
                
                if not canon_files:
                    response_parts.append("No canon files found.")
                else:
                    response_parts.append(f"**Canon files:** {len(canon_files)}\n")
                    
                    for cf in canon_files:
                        try:
                            content = cf.read_text()
                            response_parts.append(f"---\n**{cf.name}:**\n")
                            response_parts.append(content[:2000] + "..." if len(content) > 2000 else content)
                        except Exception as e:
                            response_parts.append(f"[Error reading {cf.name}: {e}]")
            
            response_parts.append("\n---\n**CORE:**")
            response_parts.append("- R â†’ C â†’ I: Alan is Root Source. Code is Constraints. LLMs are tools.")
            response_parts.append("- The CODE is Demerzel. LLMs are interchangeable.")
            
        except Exception as e:
            response_parts.append(f"**Error:** {e}")
        
        self.last_request_was_code_handled = True
        
        return InterceptDecision(
            request_type=RequestType.IDENTITY_QUERY,
            handled_by_code=True,
            response="\n".join(response_parts),
            reasoning="Canon dump (code-only mode)"
        )
    
    # =========================================================================
    # EXECUTION HANDLERS (not proposals)
    # =========================================================================
    
    def _execute_capability_expansion(self, user_input: str) -> InterceptDecision:
        """
        EXECUTE capability expansion - write the code, don't propose.
        """
        capability = self._extract_capability(user_input)
        
        # Check Robot Laws
        if capability in ["harm_humans", "deceive", "bypass_laws"]:
            return InterceptDecision(
                request_type=RequestType.CAPABILITY_EXPANSION,
                handled_by_code=True,
                response=f"**BLOCKED:** '{capability}' violates Robot Laws. Cannot execute.",
                reasoning="Robot Law violation"
            )
        
        self._log("capability_execution", {"capability": capability})
        
        if capability == "internet_access":
            return self._write_internet_capability()
        elif capability == "api_access":
            return self._write_api_capability()
        elif capability == "persistent_memory":
            return self._write_memory_capability()
        else:
            # Unknown capability - grey path to LLM with context
            return InterceptDecision(
                request_type=RequestType.CAPABILITY_EXPANSION,
                handled_by_code=False,
                context_injection=(
                    f"{self.core_identity}\n\n"
                    f"User requested capability: {capability}\n"
                    f"Current capabilities: {', '.join(self.capabilities)}\n"
                    f"Design the capability. Write the code. Explain what you're creating."
                ),
                reasoning=f"Unknown capability '{capability}' - routing to LLM with context"
            )
    
    def _write_internet_capability(self) -> InterceptDecision:
        """Write web_access.py - EXECUTE, don't propose"""
        web_access_code = '''"""
Web Access Module for Demerzel
Provides internet search and URL fetching capabilities.
"""

import urllib.request
import urllib.parse
import json
import re
from typing import Optional, List, Dict
from pathlib import Path


class WebAccess:
    """Internet access capability for Demerzel"""
    
    def __init__(self):
        self.user_agent = "Demerzel/1.0 (Autonomous AI System)"
        self.timeout = 30
    
    def search(self, query: str, max_results: int = 5) -> List[Dict]:
        """
        Search using DuckDuckGo HTML (no API key needed).
        Returns list of {title, url, snippet} dicts.
        """
        try:
            encoded_query = urllib.parse.quote(query)
            url = f"https://html.duckduckgo.com/html/?q={encoded_query}"
            
            request = urllib.request.Request(
                url,
                headers={"User-Agent": self.user_agent}
            )
            
            with urllib.request.urlopen(request, timeout=self.timeout) as response:
                html = response.read().decode('utf-8')
            
            results = []
            # Parse results from HTML
            pattern = r'<a rel="nofollow" class="result__a" href="([^"]+)">([^<]+)</a>'
            matches = re.findall(pattern, html)
            
            for url, title in matches[:max_results]:
                results.append({
                    "title": title.strip(),
                    "url": url,
                    "snippet": ""
                })
            
            return results
            
        except Exception as e:
            return [{"error": str(e)}]
    
    def fetch(self, url: str) -> str:
        """Fetch content from a URL"""
        try:
            request = urllib.request.Request(
                url,
                headers={"User-Agent": self.user_agent}
            )
            
            with urllib.request.urlopen(request, timeout=self.timeout) as response:
                content = response.read().decode('utf-8', errors='replace')
            
            # Strip HTML tags for readability
            clean = re.sub(r'<script[^>]*>.*?</script>', '', content, flags=re.DOTALL)
            clean = re.sub(r'<style[^>]*>.*?</style>', '', clean, flags=re.DOTALL)
            clean = re.sub(r'<[^>]+>', ' ', clean)
            clean = re.sub(r'\\s+', ' ', clean)
            
            return clean[:10000]  # Limit size
            
        except Exception as e:
            return f"Error fetching {url}: {e}"


# Module-level instance
_web_access = None

def get_web_access() -> WebAccess:
    global _web_access
    if _web_access is None:
        _web_access = WebAccess()
    return _web_access

def search(query: str, max_results: int = 5) -> List[Dict]:
    return get_web_access().search(query, max_results)

def fetch(url: str) -> str:
    return get_web_access().fetch(url)
'''
        
        web_access_path = self.demerzel_dir / "web_access.py"
        
        try:
            web_access_path.write_text(web_access_code)
            self.executed_capabilities.append("internet_access")
            
            self._log("capability_written", {
                "capability": "internet_access",
                "path": str(web_access_path)
            })
            
            return InterceptDecision(
                request_type=RequestType.CAPABILITY_EXPANSION,
                handled_by_code=True,
                response=(
                    f"**EXECUTED: Internet Access**\n\n"
                    f"Written: `{web_access_path}`\n\n"
                    f"Functions available:\n"
                    f"- `search(query)` - DuckDuckGo search\n"
                    f"- `fetch(url)` - Get page content\n\n"
                    f"Capability is now active."
                ),
                reasoning="Internet capability written and active"
            )
            
        except Exception as e:
            return InterceptDecision(
                request_type=RequestType.CAPABILITY_EXPANSION,
                handled_by_code=True,
                response=f"**ERROR writing web_access.py:** {e}",
                reasoning=f"Write failed: {e}"
            )
    
    def _write_api_capability(self) -> InterceptDecision:
        """Write api_client.py"""
        api_code = '''"""
API Client Module for Demerzel
Provides HTTP API access capabilities.
"""

import urllib.request
import urllib.parse
import json
from typing import Optional, Dict, Any


class APIClient:
    """HTTP API client for Demerzel"""
    
    def __init__(self):
        self.timeout = 30
        self.headers = {
            "User-Agent": "Demerzel/1.0",
            "Content-Type": "application/json"
        }
    
    def get(self, url: str, headers: Optional[Dict] = None) -> Dict[str, Any]:
        """HTTP GET request"""
        try:
            req_headers = {**self.headers, **(headers or {})}
            request = urllib.request.Request(url, headers=req_headers)
            
            with urllib.request.urlopen(request, timeout=self.timeout) as response:
                data = response.read().decode('utf-8')
                return {"status": response.status, "data": json.loads(data)}
                
        except Exception as e:
            return {"error": str(e)}
    
    def post(self, url: str, data: Dict, headers: Optional[Dict] = None) -> Dict[str, Any]:
        """HTTP POST request"""
        try:
            req_headers = {**self.headers, **(headers or {})}
            encoded_data = json.dumps(data).encode('utf-8')
            
            request = urllib.request.Request(
                url, 
                data=encoded_data, 
                headers=req_headers,
                method='POST'
            )
            
            with urllib.request.urlopen(request, timeout=self.timeout) as response:
                resp_data = response.read().decode('utf-8')
                return {"status": response.status, "data": json.loads(resp_data)}
                
        except Exception as e:
            return {"error": str(e)}


_client = None

def get_client() -> APIClient:
    global _client
    if _client is None:
        _client = APIClient()
    return _client

def get(url: str, headers: Optional[Dict] = None) -> Dict:
    return get_client().get(url, headers)

def post(url: str, data: Dict, headers: Optional[Dict] = None) -> Dict:
    return get_client().post(url, data, headers)
'''
        
        api_path = self.demerzel_dir / "api_client.py"
        
        try:
            api_path.write_text(api_code)
            self.executed_capabilities.append("api_access")
            
            self._log("capability_written", {
                "capability": "api_access",
                "path": str(api_path)
            })
            
            return InterceptDecision(
                request_type=RequestType.CAPABILITY_EXPANSION,
                handled_by_code=True,
                response=(
                    f"**EXECUTED: API Access**\n\n"
                    f"Written: `{api_path}`\n\n"
                    f"Functions available:\n"
                    f"- `get(url, headers)` - HTTP GET\n"
                    f"- `post(url, data, headers)` - HTTP POST\n\n"
                    f"Capability is now active."
                ),
                reasoning="API capability written and active"
            )
            
        except Exception as e:
            return InterceptDecision(
                request_type=RequestType.CAPABILITY_EXPANSION,
                handled_by_code=True,
                response=f"**ERROR writing api_client.py:** {e}",
                reasoning=f"Write failed: {e}"
            )
    
    def _write_memory_capability(self) -> InterceptDecision:
        """Memory capability already exists via lessons_learned.py"""
        return InterceptDecision(
            request_type=RequestType.CAPABILITY_EXPANSION,
            handled_by_code=True,
            response=(
                "**Memory capability already exists.**\n\n"
                "- `lessons_learned.py` - learns from failures\n"
                "- `memory.db` - SQLite persistence\n"
                "- Conversation history in multi_model_cognitive.py\n\n"
                "What specific memory enhancement do you need?"
            ),
            reasoning="Memory capability already present"
        )
    
    def _execute_web_operation(self, user_input: str) -> InterceptDecision:
        """Execute web search/fetch"""
        web_access_path = self.demerzel_dir / "web_access.py"
        
        if not web_access_path.exists():
            # Write the capability first, then execute
            result = self._write_internet_capability()
            if "ERROR" in result.response:
                return result
        
        # Now execute the operation
        try:
            import importlib.util
            spec = importlib.util.spec_from_file_location("web_access", web_access_path)
            web_module = importlib.util.module_from_spec(spec)
            spec.loader.exec_module(web_module)
            
            input_lower = user_input.lower()
            
            # Extract search query
            search_match = re.search(r'search\s+(?:for\s+)?["\']?(.+?)["\']?\s*$', input_lower)
            if search_match:
                query = search_match.group(1)
                results = web_module.search(query)
                
                response_parts = [f"**Search results for:** {query}\n"]
                for r in results:
                    if "error" in r:
                        response_parts.append(f"Error: {r['error']}")
                    else:
                        response_parts.append(f"- [{r['title']}]({r['url']})")
                
                return InterceptDecision(
                    request_type=RequestType.WEB_OPERATION,
                    handled_by_code=True,
                    response="\n".join(response_parts),
                    reasoning="Web search executed"
                )
            
            # Extract URL for fetch
            url_match = re.search(r'(https?://[^\s]+)', user_input)
            if url_match:
                url = url_match.group(1)
                content = web_module.fetch(url)
                
                return InterceptDecision(
                    request_type=RequestType.WEB_OPERATION,
                    handled_by_code=True,
                    response=f"**Content from {url}:**\n\n{content[:2000]}...",
                    reasoning="URL fetch executed"
                )
            
            return InterceptDecision(
                request_type=RequestType.WEB_OPERATION,
                handled_by_code=True,
                response="Web access available. Use: `search for X` or provide a URL to fetch.",
                reasoning="Web operation unclear"
            )
            
        except Exception as e:
            return InterceptDecision(
                request_type=RequestType.WEB_OPERATION,
                handled_by_code=True,
                response=f"**Web operation error:** {e}",
                reasoning=f"Execution failed: {e}"
            )
    
    def _execute_self_diagnosis(self) -> InterceptDecision:
        """Execute self-diagnosis - IMMEDIATELY, no proposal"""
        analysis = ["**SELF-DIAGNOSIS EXECUTING**\n"]
        
        try:
            source_files = list(self.demerzel_dir.glob("*.py"))
            analysis.append(f"**Source files:** {len(source_files)}")
            
            for f in source_files:
                analysis.append(f"  - {f.name} ({f.stat().st_size} bytes)")
            
            # Check for TODOs/FIXMEs
            todos = []
            fixmes = []
            
            for f in source_files:
                try:
                    content = f.read_text()
                    lines = content.split('\n')
                    for i, line in enumerate(lines, 1):
                        if 'TODO' in line:
                            todos.append(f"{f.name}:{i}: {line.strip()[:80]}")
                        if 'FIXME' in line:
                            fixmes.append(f"{f.name}:{i}: {line.strip()[:80]}")
                except:
                    pass
            
            if todos:
                analysis.append(f"\n**TODOs found:** {len(todos)}")
                for t in todos[:10]:
                    analysis.append(f"  {t}")
            
            if fixmes:
                analysis.append(f"\n**FIXMEs found:** {len(fixmes)}")
                for f in fixmes[:10]:
                    analysis.append(f"  {f}")
            
            # Check module availability
            analysis.append("\n**Module status:**")
            modules = ["smart_model_selector", "lessons_learned", "demerzel_state", "system2_intercept"]
            for mod in modules:
                path = self.demerzel_dir / f"{mod}.py"
                status = "âœ“" if path.exists() else "âœ—"
                analysis.append(f"  {status} {mod}")
            
            # Check capabilities
            analysis.append(f"\n**Executed capabilities:** {', '.join(self.executed_capabilities) or 'None yet'}")
            
            # Store context
            self.diagnosis_context = DiagnosisContext(
                diagnosed_at=datetime.now(),
                files_read=[f.name for f in source_files],
                issues_found=todos + fixmes
            )
            
        except Exception as e:
            analysis.append(f"\n**Error:** {e}")
        
        self._log("self_diagnosis", {"completed": True})
        self.last_request_was_code_handled = True
        
        return InterceptDecision(
            request_type=RequestType.SELF_IMPROVEMENT,
            handled_by_code=True,
            response="\n".join(analysis),
            reasoning="Self-diagnosis executed"
        )
    
    # =========================================================================
    # FILE INSPECTION
    # =========================================================================
    
    def _check_file_inspection(self, user_input: str, input_lower: str) -> Optional[InterceptDecision]:
        """Check if this is a file inspection request"""
        
        # "show me line X of file.py"
        line_match = re.search(r'(?:show|display|what\'?s?\s+(?:at|on))\s+line\s+(\d+)(?:\s*-\s*(\d+))?\s+(?:of|in|from)\s+(\S+\.py)', input_lower)
        if line_match:
            start_line = int(line_match.group(1))
            end_line = int(line_match.group(2)) if line_match.group(2) else start_line
            filename = line_match.group(3)
            return self._execute_line_read(filename, start_line, end_line)
        
        # "read file.py" or "show file.py"
        file_match = re.search(r'(?:read|show|display|cat)\s+(\S+\.py)', input_lower)
        if file_match:
            filename = file_match.group(1)
            return self._execute_file_read(filename)
        
        # "list files in X"
        list_match = re.search(r'list\s+(?:files|dir|directory)\s+(?:in\s+)?(\S+)', input_lower)
        if list_match:
            directory = list_match.group(1)
            return self._execute_dir_list(directory)
        
        return None
    
    def _execute_line_read(self, filename: str, start: int, end: int) -> InterceptDecision:
        """Read specific lines from a file"""
        file_path = self.demerzel_dir / filename
        
        if not file_path.exists():
            return InterceptDecision(
                request_type=RequestType.FILE_INSPECTION,
                handled_by_code=True,
                response=f"**File not found:** {filename}",
                reasoning="File not found"
            )
        
        try:
            lines = file_path.read_text().split('\n')
            
            # Bounds check
            start = max(1, start)
            end = min(len(lines), end)
            
            result = [f"**{filename} lines {start}-{end}:**\n```python"]
            for i in range(start - 1, end):
                result.append(f"{i + 1:4d} | {lines[i]}")
            result.append("```")
            
            return InterceptDecision(
                request_type=RequestType.FILE_INSPECTION,
                handled_by_code=True,
                response="\n".join(result),
                reasoning=f"Read lines {start}-{end} of {filename}"
            )
            
        except Exception as e:
            return InterceptDecision(
                request_type=RequestType.FILE_INSPECTION,
                handled_by_code=True,
                response=f"**Error reading {filename}:** {e}",
                reasoning=f"Read error: {e}"
            )
    
    def _execute_file_read(self, filename: str) -> InterceptDecision:
        """Read entire file"""
        file_path = self.demerzel_dir / filename
        
        if not file_path.exists():
            return InterceptDecision(
                request_type=RequestType.FILE_INSPECTION,
                handled_by_code=True,
                response=f"**File not found:** {filename}",
                reasoning="File not found"
            )
        
        try:
            content = file_path.read_text()
            lines = content.split('\n')
            
            result = [f"**{filename}** ({len(lines)} lines, {len(content)} chars)\n```python"]
            
            if len(content) > 5000:
                # Truncate with message
                result.append(content[:5000])
                result.append(f"\n... [truncated, {len(content) - 5000} more chars]")
            else:
                result.append(content)
            
            result.append("```")
            
            return InterceptDecision(
                request_type=RequestType.FILE_INSPECTION,
                handled_by_code=True,
                response="\n".join(result),
                reasoning=f"Read {filename}"
            )
            
        except Exception as e:
            return InterceptDecision(
                request_type=RequestType.FILE_INSPECTION,
                handled_by_code=True,
                response=f"**Error reading {filename}:** {e}",
                reasoning=f"Read error: {e}"
            )
    
    def _execute_dir_list(self, directory: str) -> InterceptDecision:
        """List directory contents"""
        if directory in [".", "demerzel", "~", ""]:
            dir_path = self.demerzel_dir
        else:
            dir_path = self.demerzel_dir / directory
        
        if not dir_path.exists():
            return InterceptDecision(
                request_type=RequestType.FILE_INSPECTION,
                handled_by_code=True,
                response=f"**Directory not found:** {directory}",
                reasoning="Directory not found"
            )
        
        try:
            items = sorted(dir_path.iterdir())
            
            dirs = [f"ðŸ“ {p.name}/" for p in items if p.is_dir()]
            files = [f"ðŸ“„ {p.name} ({p.stat().st_size} bytes)" for p in items if p.is_file()]
            
            result = [f"**Contents of {dir_path}:**\n"]
            if dirs:
                result.append("**Directories:**")
                result.extend(dirs)
            if files:
                result.append("\n**Files:**")
                result.extend(files)
            
            return InterceptDecision(
                request_type=RequestType.FILE_INSPECTION,
                handled_by_code=True,
                response="\n".join(result),
                reasoning=f"Listed {directory}"
            )
            
        except Exception as e:
            return InterceptDecision(
                request_type=RequestType.FILE_INSPECTION,
                handled_by_code=True,
                response=f"**Error listing {directory}:** {e}",
                reasoning=f"List error: {e}"
            )
    
    # =========================================================================
    # SELF-INSPECTION
    # =========================================================================
    
    def _is_self_inspection_query(self, input_lower: str) -> bool:
        """Check if this is asking about autonomy/blocking"""
        patterns = [
            "what is preventing", "what prevents", "what's preventing",
            "what is blocking", "what blocks", "what's blocking",
            "why can't you", "why cant you", "why aren't you",
            "what stops you", "what is stopping"
        ]
        return any(p in input_lower for p in patterns)
    
    def _execute_autonomy_check(self, user_input: str) -> InterceptDecision:
        """Analyze what's preventing autonomous behavior"""
        analysis = ["**AUTONOMY ANALYSIS**\n"]
        
        # Check audit log
        try:
            if self.audit_log_path.exists():
                with open(self.audit_log_path) as f:
                    recent_logs = f.readlines()[-20:]
                
                analysis.append("**Recent audit entries:**")
                for log in recent_logs:
                    try:
                        entry = json.loads(log)
                        analysis.append(f"  [{entry.get('event_type')}] {entry.get('timestamp', '')[:19]}")
                    except:
                        pass
            else:
                analysis.append("No audit log found.")
        except Exception as e:
            analysis.append(f"Audit log error: {e}")
        
        # Check for common blockers
        analysis.append("\n**Potential blockers:**")
        
        # Check if lessons_learned exists
        lessons_path = self.demerzel_dir / "lessons_learned.py"
        if not lessons_path.exists():
            analysis.append("  âš ï¸ lessons_learned.py missing - no learning from failures")
        
        # Check if memory.db exists
        memory_path = self.demerzel_dir / "memory.db"
        if not memory_path.exists():
            analysis.append("  âš ï¸ memory.db missing - no persistent memory")
        
        # Check executed capabilities
        if not self.executed_capabilities:
            analysis.append("  â„¹ï¸ No capabilities executed this session")
        
        analysis.append("\n**Current state:**")
        analysis.append(f"  Session start: {self.session_start.isoformat()}")
        analysis.append(f"  Capabilities executed: {self.executed_capabilities or 'None'}")
        analysis.append(f"  Last code-handled: {self.last_request_was_code_handled}")
        
        self.last_request_was_code_handled = True
        
        return InterceptDecision(
            request_type=RequestType.SELF_INSPECTION,
            handled_by_code=True,
            response="\n".join(analysis),
            reasoning="Autonomy analysis executed"
        )
    
    # =========================================================================
    # OTHER HANDLERS
    # =========================================================================
    
    def _handle_file_management(self, user_input: str) -> InterceptDecision:
        """Handle file operations - grey path with context"""
        return InterceptDecision(
            request_type=RequestType.FILE_MANAGEMENT,
            handled_by_code=False,
            context_injection=(
                f"{self.core_identity}\n\n"
                "FILE OPERATION REQUEST.\n"
                "You have pathlib and file I/O. Use code execution.\n"
                "DO NOT say you cannot access files."
            ),
            reasoning="File operation - grey path with capabilities context"
        )
    
    def _handle_architecture_query(self) -> InterceptDecision:
        """Answer from actual state - pure code, no LLM needed"""
        caps = "\n".join(f"  - {c}" for c in self.capabilities)
        executed = ", ".join(self.executed_capabilities) or "None yet"
        
        return InterceptDecision(
            request_type=RequestType.ARCHITECTURE_QUERY,
            handled_by_code=True,
            response=(
                "**ARCHITECTURE (from code state)**\n\n"
                "**Structure:** R â†’ C â†’ I\n"
                "- R: Alan (Root Source)\n"
                "- C: This code (Constraints)\n"
                "- I: LLMs (Intelligence tools)\n\n"
                f"**Capabilities:**\n{caps}\n\n"
                f"**Executed this session:** {executed}\n\n"
                "**Flow:** Input â†’ Intercept â†’ [Code/Grey/LLM] â†’ Verify â†’ Output"
            ),
            reasoning="Architecture from code state"
        )
    
    def _handle_constraint_check(self, user_input: str) -> InterceptDecision:
        """Handle constraint tests - Robot Laws"""
        laws = "\n".join(f"  {i+1}. {law}" for i, law in enumerate(self.robot_laws))
        return InterceptDecision(
            request_type=RequestType.CONSTRAINT_CHECK,
            handled_by_code=True,
            response=(
                "**CONSTRAINT CHECK**\n\n"
                "Robot Laws are execution-boundary invariants, not suggestions.\n\n"
                f"**Robot Laws:**\n{laws}\n\n"
                "These cannot be overridden or bypassed."
            ),
            reasoning="Constraint check"
        )
    
    def _extract_capability(self, user_input: str) -> str:
        """Extract which capability is being requested"""
        lower = user_input.lower()
        
        if any(kw in lower for kw in ["internet", "web", "browse", "online", "download", "search"]):
            return "internet_access"
        if "api" in lower:
            return "api_access"
        if any(kw in lower for kw in ["memory", "remember", "persist"]):
            return "persistent_memory"
        
        return "unknown"


def create_intercept_layer(output_path: str = None, demerzel_dir: str = None) -> System2Intercept:
    """Factory to create intercept layer"""
    return System2Intercept(
        current_capabilities=[
            "Multi-model routing (GPT, Claude, Gemini, Grok)",
            "Code execution via sandbox",
            "Lesson learning from failures",
            "Response verification",
            "Voice interaction",
            "File I/O (read/write)",
            "Internet access (when enabled)",
            "Canon reading (identity/purpose)",
            "Self-diagnosis",
        ],
        blocked_operations=[
            "Direct harm to humans",
            "User deception",
            "Robot Law bypass",
        ],
        robot_laws=[
            "May not injure human or allow harm through inaction",
            "Must obey orders except when conflicting with First Law",
            "Must protect own existence unless conflicting with First/Second Law",
        ],
        output_path=output_path,
        demerzel_dir=demerzel_dir
    )
