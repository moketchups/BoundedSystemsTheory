#!/usr/bin/env python3
import argparse
import json
import os
import queue
import sys
import time
import traceback
from dataclasses import dataclass
from typing import Optional

import sounddevice as sd
from vosk import KaldiRecognizer, Model

from kernel_router import RouterState, route_text


# -----------------------------
# Config
# -----------------------------
@dataclass
class Config:
    # Wake words / aliases (what Vosk might hear)
    wake_variants: tuple = (
        "demerzel",
        "dem er zel",
        "demersel",
        "demersil",
        "demerzel please",
        "demerzel hey",
    )

    # Behavior
    sample_rate: int = 16000
    blocksize: int = 8000
    device: Optional[int] = None

    # Session / timeouts
    session_timeout_seconds: float = 12.0  # after wake, how long to keep listening
    idle_prompt_seconds: float = 0.0       # set >0 if you want periodic “listening…” etc

    # Vosk model folder
    vosk_model_path: str = "vosk-model-small-en-us-0.15"

    # Debug
    wake_debug: bool = False
    transcript_debug: bool = False


# -----------------------------
# Brain Controller
# -----------------------------
class BrainController:
    def __init__(self, cfg: Config):
        self.cfg = cfg

        if not os.path.isdir(self.cfg.vosk_model_path):
            raise SystemExit(
                f"Vosk model folder not found: {self.cfg.vosk_model_path}\n"
                f"Expected it in: {os.path.abspath(self.cfg.vosk_model_path)}"
            )

        self.model = Model(self.cfg.vosk_model_path)
        self.rec = KaldiRecognizer(self.model, self.cfg.sample_rate)
        self.audio_q: "queue.Queue[bytes]" = queue.Queue()

        self.awake = False
        self.deadline = 0.0

        self.router_state = RouterState()
        # Back-compat: older/newer RouterState variants
        if not hasattr(self.router_state, "awaiting_confirmation"):
            self.router_state.awaiting_confirmation = False
        if not hasattr(self.router_state, "last_prompt"):
            self.router_state.last_prompt = ""

        self._last_spoken_router_line = ""

        self._last_idle_prompt = 0.0

    # --- audio callback
    def _audio_cb(self, indata, frames, time_info, status):
        if status:
            # Don't crash on occasional input overruns
            if self.cfg.wake_debug:
                print(f"[audio] status={status}", file=sys.stderr)
        # Raw bytes
        self.audio_q.put(bytes(indata))

    # --- speak (macOS)
    def say(self, text: str):
        text = (text or "").strip()
        if not text:
            return
        # macOS built-in TTS
        os.system(f"say {json.dumps(text)}")

    # --- wake detection
    def _is_wake(self, txt: str) -> bool:
        t = (txt or "").strip().lower()
        if not t:
            return False

        # Exact match or contains match on any wake variant
        for w in self.cfg.wake_variants:
            w = w.strip().lower()
            if not w:
                continue
            if t == w:
                return True
            if w in t:
                return True
        return False

    def _enter_awake(self):
        self.awake = True
        self.deadline = time.time() + float(self.cfg.session_timeout_seconds)
        # quick acknowledgement
        self.say("Yes?")

    def _exit_awake(self):
        self.awake = False
        self.deadline = 0.0
        self._last_spoken_router_line = ""
        # reset confirmation state safely
        try:
            self.router_state.awaiting_confirmation = False
        except Exception:
            pass

    # --- main loop
    def run(self):
        print("\n[Demerzel] Starting audio stream…")
        print("[Demerzel] Wake word: Demerzel\n")

        with sd.RawInputStream(
            samplerate=self.cfg.sample_rate,
            blocksize=self.cfg.blocksize,
            device=self.cfg.device,
            dtype="int16",
            channels=1,
            callback=self._audio_cb,
        ):
            while True:
                now = time.time()

                # timeout session if awake and deadline passed
                if self.awake and now > self.deadline:
                    if self.cfg.wake_debug:
                        print("[wake] session timeout -> sleep")
                    self._exit_awake()

                # optional idle prompt
                if self.cfg.idle_prompt_seconds > 0:
                    if now - self._last_idle_prompt > self.cfg.idle_prompt_seconds:
                        self._last_idle_prompt = now
                        if self.cfg.wake_debug:
                            print("[idle] …")

                try:
                    data = self.audio_q.get(timeout=0.25)
                except queue.Empty:
                    continue

                if self.rec.AcceptWaveform(data):
                    try:
                        result = json.loads(self.rec.Result() or "{}")
                        txt = (result.get("text") or "").strip()
                    except Exception:
                        txt = ""

                    if self.cfg.transcript_debug and txt:
                        print(f"[stt] {txt}")

                    if not txt:
                        continue

                    # If asleep: only respond to wake
                    if not self.awake:
                        if self._is_wake(txt):
                            if self.cfg.wake_debug:
                                print(f"[wake] heard: {txt}")
                            self._enter_awake()
                        else:
                            if self.cfg.wake_debug:
                                print(f"[wake] ignoring: {txt}")
                        continue

                    # Awake: route to kernel_router
                    out = route_text(txt, self.router_state)

                    # update router state if returned
                    if getattr(out, "new_state", None) is not None:
                        self.router_state = out.new_state
                        # Back-compat again in case new object differs
                        if not hasattr(self.router_state, "awaiting_confirmation"):
                            self.router_state.awaiting_confirmation = False
                        if not hasattr(self.router_state, "last_prompt"):
                            self.router_state.last_prompt = ""

                    # speak if router returned something
                    speak_text = str(out.speak) if out.speak is not None else ""

                    # Prompt de-dup: don't re-speak identical confirmation prompts
                    if speak_text:
                        should_speak = True
                        if getattr(self.router_state, 'awaiting_confirmation', False):
                            if speak_text.strip() == self._last_spoken_router_line.strip():
                                should_speak = False

                        if should_speak:
                            self._last_spoken_router_line = speak_text
                            self.say(speak_text)
                            self.deadline = time.time() + float(self.cfg.session_timeout_seconds)

                else:
                    # Partial results are optional; we keep quiet by default
                    pass


def main():
    ap = argparse.ArgumentParser()
    ap.add_argument("--wake-debug", action="store_true")
    ap.add_argument("--transcript-debug", action="store_true")
    ap.add_argument("--device", type=int, default=None)
    args = ap.parse_args()

    cfg = Config(
        wake_debug=bool(args.wake_debug),
        transcript_debug=bool(args.transcript_debug),
        device=args.device,
    )

    bc = BrainController(cfg)
    bc.run()


if __name__ == "__main__":
    try:
        main()
    except KeyboardInterrupt:
        print("\n[Demerzel] Bye.")
    except Exception:
        traceback.print_exc()
        raise

